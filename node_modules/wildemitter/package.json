{
  "name": "wildemitter",
  "version": "1.2.0",
  "author": {
    "name": "Henrik Joreteg",
    "email": "henrik@andyet.net"
  },
  "scripts": {
    "build": "node ./build.js",
    "test": "npm run build && nodeunit test.js"
  },
  "description": "A super lightweight EventEmitter similar to what comes in Node.js, but with a support for wildcard events '*' and grouped handlers",
  "repository": {
    "type": "git",
    "url": "https://github.com/HenrikJoreteg/wildemitter.git"
  },
  "devDependencies": {
    "colors": "~0.6.2",
    "mustache": "~0.8.1",
    "nodeunit": "~0.8.2",
    "yetify": "~0.1.0"
  },
  "keywords": [
    "events",
    "emitter",
    "browser"
  ],
  "main": "wildemitter.js",
  "readme": "# WildEmitter - A lightweight event emitter that supports wildcard handlers\r\n\r\n## What's an event emitter?\r\nIf you've ever listened for a click event in a browser you've used an emitter. But, user interaction isn't the only thing that can trigger an event worth listening to. You can also make other objects capable of emitting events. That's what wildemitter is for. You can extend your objects with it so that you can emit events from them and register handlers on them. This pattern helps you write more re-usable code because your object don't have to know how it's going to be used. It can simply emit events any time something happens that other code *may* be interested in.\r\n\r\nYou'll see this type of pattern a lot in node.js. Where lots of things in the standard libraries inherit from EventEmitter and emit various events to indicate progress, errors, completion, etc.\r\n\r\nSo, why make another one? Aren't there others already?\r\n\r\nWell, yes there are, but not quite what I wanted. This one is largely based on the emitter in @visionmedia's UIKit. So, much props to TJ for that. But there were a few more things I wanted. Specifically the following:\r\n- Super lightweight\r\n- Support for browser/node.js (browser use requires a CommonJS wrapper of some kind, like Stitch or Browserify)\r\n- Support for wildcard handlers (`*` or `something*`)\r\n- Support for grouping registered handlers and unbinding them all by their group name. This is really handy when, for example, you want unbind all handlers associated with a given \"sub-page\" within a single page app.\r\n- Available with Bower, `bower install wildemitter --save`\r\n\r\n## How do I use it? ##\r\n\r\n```js\r\nvar Emitter = require('./wildemitter');\r\n\r\n// the example object we're making\r\nfunction Fruit(name) {\r\n    this.name = name;\r\n}\r\n\r\n//Mix the emitter behaviour into Fruit\r\nEmitter.mixin(Fruit);\r\n\r\n// a function that emits an events when called\r\nFruit.prototype.test = function () {\r\n    this.emit('test', this.name);\r\n};\r\n\r\n// set up some test fruits\r\nvar apple = new Fruit('apple');\r\n\r\napple.on('*', function () {\r\n    console.log('\"*\" handler called', arguments);\r\n});\r\n\r\napple.on('te*', function () {\r\n    console.log('\"te*\" handler called', arguments);\r\n});\r\n\r\napple.on('test', function () {\r\n    console.log('\"test\" handler called', arguments);\r\n});\r\n\r\n// calling the method that emits events.\r\napple.test();\r\n\r\n// it should write the following the log:\r\n/*\r\n\"test\" handler called { '0': 'apple' }\r\n\"*\" handler called { '0': 'test', '1': 'apple' }\r\n\"te*\" handler called { '0': 'test', '1': 'apple' }\r\n*/\r\n\r\n// this will remove any handlers explicitly listening for 'test' events.\r\napple.off('test');\r\n\r\n// calling our method again would this time only call the two wildcard handlers\r\n// producing the following output\r\n/*\r\n\"*\" handler called { '0': 'test', '1': 'apple' }\r\n\"te*\" handler called { '0': 'test', '1': 'apple' }\r\n*/\r\n\r\n// grouped handlers example, we'll create another fruit\r\nvar orange = new Fruit('orange');\r\n\r\n// In this case \"today\" is the name of the group.\r\n// here we'll bind some handlers that all pass 'today'\r\n// as the group name\r\norange.on('test', 'today', someHandler);\r\norange.on('someOtherEvent', 'today', someHandler);\r\norange.on('*', 'today', someHandler);\r\n\r\n// we can now unbind all three of those handlers like this\r\norange.releaseGroup('today');\r\n```\r\n\r\n### The old way\r\n\r\nIf you don't want to use `Emitter.mixin`, you can still use it the old way:\r\n\r\n```js\r\nfunction Fruit(name) {\r\n    this.name = name;\r\n    \r\n    // call emitter with this context\r\n    Emitter.call(this);\r\n}\r\n\r\n// and also inherit from Emitter\r\nFruit.prototype = new Emitter;\r\n```\r\n\r\n## Including\r\n\r\nEmitters are often something you want to be able to include in another lib. There's also file called wildemitter-bare.js that doesn't have any export mechanism.\r\n\r\n## Building/Testing\r\n\r\n1. Edit files in `/src`\r\n2. Run `npm test`\r\n\r\nYou can also run build by itself: `npm run build`\r\n\r\n## Changelog\r\n\r\n- v1.0.1 [diff](https://github.com/henrikjoreteg/wildemitter/compare/v1.0.0...v1.0.1) - Fixes wildcard matching issue.\r\n- v1.0.0 [diff](https://github.com/henrikjoreteg/wildemitter/compare/v0.0.5...v1.0.0) - Copy emitter array before firing. Though its unlikely this could impact how your application functions, hence bumping the 1st major version number per semver conventions.\r\n\r\n## Credits\r\n\r\nWritten by [@HenrikJoreteg](http://twitter.com/henrikjoreteg) inspired by TJ's emitter component.\r\n\r\nContributors: https://github.com/HenrikJoreteg/wildemitter/graphs/contributors\r\n\r\n##License\r\nMIT\r\n\r\nIf you like this follow [@HenrikJoreteg](http://twitter.com/henrikjoreteg) on twitter.\r\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/HenrikJoreteg/wildemitter/issues"
  },
  "_id": "wildemitter@1.2.0",
  "_from": "wildemitter@^1.0.1"
}
